/*
Name:		arduino_watch.ino
Created:	9/25/2015 11:33:01 PM
Author:	Albert
*/

static const uint8_t PROGMEM settings_screen[] = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xf0, 0xff, 0xf3, 0xf3, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xe6, 0x7f, 0xf3, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xf3, 0xf0, 0xe0, 0xe0, 0xf1, 0xe0, 0xf0, 0x78, 0x3f, 0xff, 0xf0,
	0xf9, 0xe6, 0x73, 0xf3, 0xf9, 0xe2, 0x64, 0x73, 0xff, 0xff, 0xf0,
	0xfc, 0xe0, 0x73, 0xf3, 0xf9, 0xe6, 0x66, 0x78, 0x7f, 0xff, 0xf0,
	0xe6, 0x67, 0xf2, 0x72, 0x79, 0xe6, 0x64, 0x7f, 0x3f, 0xff, 0xf0,
	0xf0, 0x70, 0x78, 0xf8, 0xf0, 0xe6, 0x70, 0x70, 0x7f, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xe0, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xf0,
	0xff, 0xc2, 0x0, 0x43, 0xff, 0xff, 0xff, 0xff, 0xff, 0x33, 0xf0,
	0xff, 0x80, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xfc, 0xf0,
	0xff, 0x80, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0x70,
	0xff, 0x80, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xfe, 0x70,
	0xff, 0x80, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xf8, 0x70,
	0xff, 0xc0, 0x0, 0x3, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xe0, 0x70,
	0xff, 0x80, 0x7e, 0x1, 0xff, 0xff, 0xff, 0xf3, 0xff, 0x80, 0x70,
	0xff, 0x80, 0xff, 0x1, 0xff, 0xff, 0xe0, 0xf, 0xfe, 0x0, 0x70,
	0xfe, 0x1, 0xff, 0x80, 0x7f, 0xff, 0x1f, 0xff, 0xf8, 0x0, 0xf0,
	0xfc, 0x3, 0xff, 0xc0, 0x3f, 0xfc, 0xff, 0xff, 0xe0, 0x3, 0xf0,
	0xfc, 0x3, 0xff, 0xc0, 0x3f, 0xfb, 0xff, 0xff, 0x80, 0x7, 0xf0,
	0xfc, 0x3, 0xff, 0xc0, 0x3f, 0xf3, 0xe1, 0xfe, 0x0, 0x3f, 0xf0,
	0xfc, 0x3, 0xff, 0xc0, 0x3f, 0xef, 0x80, 0xfc, 0x0, 0xff, 0xf0,
	0xfe, 0x3, 0xff, 0xc0, 0x7f, 0xce, 0x0, 0x7c, 0x3, 0xff, 0xf0,
	0xff, 0x81, 0xff, 0x81, 0xff, 0xbc, 0x0, 0x7c, 0xf, 0xff, 0xf0,
	0xff, 0x80, 0xff, 0x1, 0xff, 0x80, 0x1c, 0xfc, 0x3f, 0xff, 0xf0,
	0xff, 0xc0, 0x7e, 0x3, 0xff, 0x80, 0x73, 0xf8, 0xff, 0xff, 0xf0,
	0xff, 0x80, 0x0, 0x1, 0xff, 0x81, 0xcf, 0xf1, 0xff, 0xff, 0xf0,
	0xff, 0x80, 0x0, 0x1, 0xff, 0x83, 0xbf, 0x81, 0xff, 0xff, 0xf0,
	0xff, 0x80, 0x0, 0x1, 0xff, 0x87, 0x80, 0x1, 0xff, 0xff, 0xf0,
	0xff, 0x80, 0x0, 0x1, 0xff, 0xff, 0x80, 0x3, 0xff, 0xff, 0xf0,
	0xff, 0xc2, 0x0, 0x43, 0xff, 0xff, 0x80, 0x7, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0x80, 0xf, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0x81, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0
};


static const unsigned char PROGMEM gear1[] = {
	0xff, 0xff, 0xff, 0xf8, 0x1, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xfc, 0xff, 0xe0, 0x0, 0x7f, 0xf3, 0xff, 0xf0,
	0xff, 0xf8, 0x7f, 0xe0, 0x0, 0x7f, 0xe1, 0xff, 0xf0,
	0xff, 0xf0, 0x3f, 0x80, 0x0, 0x1f, 0xc0, 0xff, 0xf0,
	0xff, 0xe0, 0x1e, 0x0, 0x0, 0x7, 0x80, 0x7f, 0xf0,
	0xff, 0xc0, 0x8, 0x0, 0x0, 0x1, 0x0, 0x3f, 0xf0,
	0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xf0,
	0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf0,
	0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf0,
	0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xf0,
	0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xf0,
	0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf0,
	0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf0,
	0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xf0,
	0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xf0,
	0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xf0,
	0xff, 0xc0, 0x0, 0x7, 0xfe, 0x0, 0x0, 0x3f, 0xf0,
	0xff, 0xc0, 0x0, 0x1f, 0xff, 0x80, 0x0, 0x3f, 0xf0,
	0xff, 0x80, 0x0, 0x3f, 0xff, 0xc0, 0x0, 0x1f, 0xf0,
	0xff, 0x80, 0x0, 0xff, 0xff, 0xf0, 0x0, 0x1f, 0xf0,
	0xff, 0x0, 0x0, 0xff, 0xff, 0xf0, 0x0, 0xf, 0xf0,
	0xff, 0x0, 0x1, 0xff, 0xff, 0xf8, 0x0, 0xf, 0xf0,
	0xc0, 0x0, 0x3, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x30,
	0x80, 0x0, 0x3, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x10,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x0, 0x0, 0x7, 0xff, 0xff, 0xfe, 0x0, 0x0, 0x0,
	0x80, 0x0, 0x3, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x10,
	0xc0, 0x0, 0x3, 0xff, 0xff, 0xfc, 0x0, 0x0, 0x30,
	0xff, 0x0, 0x1, 0xff, 0xff, 0xf8, 0x0, 0xf, 0xf0,
	0xff, 0x0, 0x0, 0xff, 0xff, 0xf0, 0x0, 0xf, 0xf0,
	0xff, 0x80, 0x0, 0xff, 0xff, 0xf0, 0x0, 0x1f, 0xf0,
	0xff, 0x80, 0x0, 0x3f, 0xff, 0xc0, 0x0, 0x1f, 0xf0,
	0xff, 0xc0, 0x0, 0x1f, 0xff, 0x80, 0x0, 0x3f, 0xf0,
	0xff, 0xc0, 0x0, 0x7, 0xfe, 0x0, 0x0, 0x3f, 0xf0,
	0xff, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xf0,
	0xff, 0xc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xf0,
	0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xf0,
	0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf0,
	0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf0,
	0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xf0,
	0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0xf0,
	0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xf0,
	0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf0,
	0xff, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xf0,
	0xff, 0xc0, 0x8, 0x0, 0x0, 0x1, 0x0, 0x3f, 0xf0,
	0xff, 0xe0, 0x1e, 0x0, 0x0, 0x7, 0x80, 0x7f, 0xf0,
	0xff, 0xf0, 0x3f, 0x80, 0x0, 0x1f, 0xc0, 0xff, 0xf0,
	0xff, 0xf8, 0x7f, 0xe0, 0x0, 0x7f, 0xe1, 0xff, 0xf0,
	0xff, 0xfc, 0xff, 0xe0, 0x0, 0x7f, 0xf3, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xe0, 0x0, 0x7f, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xf0, 0x0, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xf8, 0x1, 0xff, 0xff, 0xff, 0xf0
};

static const uint8_t PROGMEM made_by[] = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0x1f, 0xfe, 0x7f, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0x1f, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xfe, 0x4e, 0x58, 0x64, 0xcc, 0xbc, 0x7f, 0xff, 0xff, 0xff, 0xf0,
	0xfe, 0x4e, 0x10, 0x64, 0xcc, 0x18, 0x3f, 0xff, 0xff, 0xff, 0xf0,
	0xfc, 0xe6, 0x72, 0x64, 0xcc, 0x99, 0x3f, 0xff, 0xff, 0xff, 0xf0,
	0xfc, 0x6, 0x72, 0x64, 0xcc, 0x99, 0x3f, 0xff, 0xff, 0xff, 0xf0,
	0xfc, 0x6, 0x70, 0x60, 0xcc, 0x98, 0x3f, 0xff, 0xff, 0xff, 0xf0,
	0xf9, 0xf2, 0x78, 0x60, 0xcc, 0x9c, 0x7f, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xf9, 0x8c, 0xff, 0xbf, 0xf3, 0xfc, 0xf9, 0x8f, 0xf1, 0xff, 0xf0,
	0xf9, 0x8c, 0xff, 0x3f, 0xf3, 0xfe, 0x73, 0x7, 0xe0, 0xff, 0xf0,
	0xfd, 0x8d, 0xc6, 0x1c, 0x72, 0xfe, 0x73, 0x27, 0xe4, 0xff, 0xf0,
	0xfc, 0xa9, 0x92, 0x18, 0x30, 0x7e, 0x23, 0xe7, 0xe4, 0xff, 0xf0,
	0xfc, 0x21, 0xe3, 0x39, 0xf2, 0x7f, 0x27, 0xcf, 0xe4, 0xff, 0xf0,
	0xfe, 0x23, 0x93, 0x39, 0xf2, 0x7f, 0x27, 0x9f, 0xe4, 0xff, 0xf0,
	0xfe, 0x73, 0x93, 0x18, 0x32, 0x7f, 0x8f, 0x6, 0x60, 0xff, 0xf0,
	0xfe, 0x73, 0x83, 0x1c, 0x72, 0x7f, 0x8f, 0x6, 0x71, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xf3, 0xe7, 0x38, 0x38, 0x3c, 0x19, 0x9f, 0xff, 0xff, 0xff, 0xf0,
	0xf1, 0xc7, 0x39, 0x99, 0xfc, 0xc9, 0x9f, 0xff, 0xff, 0xff, 0xf0,
	0xf1, 0xc6, 0x19, 0xc9, 0xfc, 0xcc, 0x27, 0xff, 0xff, 0xff, 0xf0,
	0xf0, 0x86, 0xd9, 0xc8, 0x3c, 0x1c, 0x27, 0xff, 0xff, 0xff, 0xf0,
	0xf2, 0xa4, 0xc9, 0xc9, 0xfc, 0xce, 0x7f, 0xff, 0xff, 0xff, 0xf0,
	0xf2, 0x24, 0x9, 0xc9, 0xfc, 0xce, 0x7f, 0xff, 0xff, 0xff, 0xf0,
	0xf3, 0x64, 0xc9, 0x99, 0xfc, 0xce, 0x67, 0xff, 0xff, 0xff, 0xf0,
	0xf3, 0x64, 0xc8, 0x38, 0x3c, 0x1e, 0x67, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xaf, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xfc, 0xe7, 0x6, 0x8, 0x30, 0x3c, 0x1e, 0x79, 0x8f, 0x39, 0x90,
	0xfc, 0xe7, 0x32, 0x79, 0x9c, 0xf9, 0xee, 0x79, 0x37, 0x39, 0x30,
	0xf8, 0x67, 0x32, 0x79, 0x9c, 0xf9, 0xfc, 0x39, 0x3e, 0x19, 0x30,
	0xfb, 0x67, 0x6, 0x8, 0x3c, 0xf9, 0xfd, 0xb9, 0xe, 0xd8, 0x70,
	0xf3, 0x27, 0x32, 0x79, 0x3c, 0xf9, 0x89, 0x99, 0x84, 0xc8, 0x70,
	0xf0, 0x27, 0x32, 0x79, 0x9c, 0xf9, 0xc8, 0x19, 0xe4, 0x9, 0x30,
	0xf3, 0x27, 0x32, 0x79, 0x9c, 0xf9, 0xc9, 0x99, 0x64, 0xc9, 0x30,
	0xf3, 0x21, 0x6, 0x9, 0x9c, 0xfc, 0x19, 0x93, 0x8c, 0xc9, 0x90,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0
};

#include <Vcc.h>
const float VccCorrection = 4.12 / 4.2;  // Measured Vcc by multimeter divided by reported Vcc
Vcc vcc(VccCorrection);

#include <MemoryFree.h>//library for RAM usage information

#include <avr/interrupt.h>//library for using interrupts (used to wake up from sleep mode)
#include <avr/power.h>//Power Reduction Management library
#include <avr/sleep.h>//library for enabling the sleep mode

#include <virtuabotixRTC.h>//DS1302 RTC library 
virtuabotixRTC myRTC(18, 19, 17);// Creation of the Real Time Clock Object:  CLK, DAT, RST

#include <OneWire.h>//one wire library used by the DallasTemperature library
#include <DallasTemperature.h>//library for Communicating with the Dallas 18b20 one-wire temperature sensor
#define ONE_WIRE_BUS 3//define a pin used for one-wire communication with the Dallas 18b20 one-wire temperature sensor
OneWire oneWire(ONE_WIRE_BUS);// Setup a oneWire instance to communicate with any OneWire devices (Dallas temperature ICs)
DallasTemperature temperatureSensors(&oneWire);// Pass our oneWire reference to Dallas Temperature. 

#include <toneAC.h>//Replacement to the standard Arduino tone library with twice the volume, higher quality and higher frequency
uint8_t globalVolume = 10;

#include <SPI.h>
#include <Adafruit_GFX.h>//adafruit graphics library (for the graphic lcd)
#include <Adafruit_PCD8544.h>//PCD8544 (controller in nokia 3310/nokia 5110 lcds) plugin for the adafruit gfx library
//using softare SPI for LCD:
// pin 13 - Serial clock out (SCLK)
// pin 11 - Serial data out (DIN)
// pin 5 - Data/Command select (D/C)
// pin 4 - LCD chip select (CS)
// pin 6 - LCD reset (RST)
Adafruit_PCD8544 display = Adafruit_PCD8544(13, 11, 14, 16, 15);//creation of graphic lcd object (SCLK, DIN, D/C, CS, RST)
uint8_t StartupContrast = 50;

//pin definitions:
#define BLpin 5 //LCD backlight control pin (must be PWM)
#define flashlightPin 6//pin used for controlling the white flashlight LED (must be PWM)

#define BTN0 2 //button 0 (must be an external interrupt pin)
#define BTN1 7 //button 1
#define BTN2 8 //button 2
#define BTN3 12 //button 3
#define BTN4 21 //button 4


#define peripheralsPowerPin 20//pin used for controlling power supply of external microcotroller peripherals

//#define LEDB 9 //red led (must be PWM)
//#define LEDG 10 //green led (must be PWM)
//#define LEDR 11 //blue led (must be PWM)

bool BLstate;

void setup()   {
	Serial.begin(9600);

	////pin initialisation:
	//pinMode(LEDR, OUTPUT); digitalWrite(LEDR, HIGH);
	//pinMode(LEDG, OUTPUT); digitalWrite(LEDG, HIGH);
	//pinMode(LEDB, OUTPUT); digitalWrite(LEDB, HIGH);

	pinMode(BTN0, INPUT_PULLUP);
	pinMode(BTN1, INPUT_PULLUP);
	pinMode(BTN2, INPUT_PULLUP);
	pinMode(BTN3, INPUT_PULLUP);
	pinMode(BTN4, INPUT_PULLUP);

	pinMode(peripheralsPowerPin, OUTPUT); digitalWrite(peripheralsPowerPin, LOW);

	pinMode(BLpin, OUTPUT); digitalWrite(BLpin, LOW);

	display.begin(); //display initialisation
	display.setContrast(StartupContrast); //set display contrast
	display.setTextSize(1);
	display.clearDisplay();
	display.display();

	toneAC(100, globalVolume, 100, true);
	delay(100);
	toneAC(200, globalVolume, 100, true);
	delay(100);
	toneAC(300, globalVolume, 100, true);
	delay(100);

	LEDfadeIN(BLpin, 1);
	//analogWrite(BLpin, 150);
	BLstate = true;
	if (digitalRead(BTN3) == LOW)
		myRTC.setDS1302Time(0, 16, 2, 2, 18, 8, 2015);// seconds, minutes, hours, day of the week, day of the month, month, year
	temperatureSensors.begin();//start up the dallas temperature sensor library
	temperatureSensors.setResolution(12);//set the resolution for the Dallas 18b20 one-wire temperature sensor (9 bits by default)
}


#define numScreens 7 //number of screens in the menu
int i = 1;
int x, y;
int hours;
unsigned long previousMillis1 = 0;


//flashlight screen variables and defines:
#define nFlashlightScreen 2
uint8_t flashlightPWMValue = 0;

//converter variables and defines:
#define nConverterScreen 13
int number = 15;
bool ConverterEditing = false;
unsigned long previousMillis3 = 0;
int cursor = 1;
bool cursorState = 0;
int ConverterMode = 0;
char DECbuffer[7];
int numLen = 0;

// watch faces screen variables and defines:
#define nWatchFacesScreen 1
#define numFaces 5
byte curFace = 1;

//status screen: demo mode variables
#define nStatusScreen 10
bool demoMode = false;
unsigned long demoPreviousMillis = 0;

void loop() {

	if (digitalRead(BTN3) == LOW){
		delay(50);
		unsigned long previousMillis2 = millis();
		while (1){
			if (digitalRead(BTN3) == HIGH){
				toneAC(800, globalVolume, 50, true);
				delay(50);
				toneAC(1000, globalVolume, 50, true);
				delay(50);
				toneAC(1200, globalVolume, 50, true);
				if (BLstate == true)
					LEDfadeOUT(BLpin, 1);
				else
					LEDfadeIN(BLpin, 1);
				BLstate = !BLstate;
				break;
			}
			if (millis() - previousMillis2 >= 1000){
				if (i == nFlashlightScreen){
					toneAC(100, globalVolume, 50, true);
					delay(50);
					toneAC(200, globalVolume, 50, true);
					if (flashlightPWMValue == 0){
						flashlightPWMValue = 255;
						LEDfadeIN(flashlightPin, 1);
					}
					else{
						flashlightPWMValue = 0;
						LEDfadeOUT(flashlightPin, 1);
					}
					break;
				}
			}
			//if (millis() - previousMillis2 >= 1000){
			//	if (i == nConverterScreen){
			//		ConverterEditing = !ConverterEditing;
			//		tone(SPKRpin, 100, 50);
			//		//delay(50);
			//		//tone(SPKRpin, 400, 50);
			//		delay(50);
			//		tone(SPKRpin, 150, 50);
			//		ConverterMode = 0;
			//		break;
			//	}
			//	if (i == nStatusScreen){
			//		demoMode = !demoMode;
			//		tone(SPKRpin, 100, 50);
			//		//delay(50);
			//		//tone(SPKRpin, 400, 50);
			//		delay(50);
			//		tone(SPKRpin, 150, 50);
			//		break;
			//	}
			//}
		}
	}

	if (digitalRead(BTN0) == LOW){
		toneAC(200, globalVolume, 50, true);
		delay(50);
		toneAC(400, globalVolume, 50, true);
		while (digitalRead(BTN0) == LOW){}
		delay(20);
		sleepNow();
	}

	if (digitalRead(BTN1) == LOW){
		toneAC(200, globalVolume, 50, true);
		delay(50);
		toneAC(400, globalVolume, 50, true);
		while (digitalRead(BTN1) == LOW){}
		delay(20);
		i++;
		if (i == numScreens + 1)
			i = 1;
		//globalVolume++;
		//if (globalVolume == 11)
		//	globalVolume = 0;

	}

	if (digitalRead(BTN2) == LOW){
		toneAC(300, globalVolume, 50, true);
		delay(50);
		toneAC(500, globalVolume, 50, true);
		while (digitalRead(BTN2) == LOW){}
		delay(20);
		i--;
		if (i == 0)
			i = numScreens;
		//globalVolume--;
		//if (globalVolume == -1)
		//	globalVolume = 10;
	}
	if (digitalRead(BTN4) == LOW){

		if (i == nWatchFacesScreen){
			toneAC(500, globalVolume, 50, true);
			delay(50);
			toneAC(700, globalVolume, 50, true);
			while (digitalRead(BTN4) == LOW){}
			delay(20);
			curFace++;
			if (curFace == numFaces + 1)
				curFace = 1;
		}
	}

	switch (i){
	case 1://multiple watch faces screen
		switch (curFace){
		case 1:
			if (millis() - previousMillis1 >= 100) {
				previousMillis1 = millis();

				display.clearDisplay();
				myRTC.updateTime();

				display.setTextSize(2);
				display.setCursor(2, 6);
				display.print(myRTC.hours);
				display.print(":");
				display.print(myRTC.minutes);
				display.setTextSize(1);
				display.print(":");
				display.print(myRTC.seconds);
				display.setTextSize(2);
				display.setCursor(2, 24);
				//display.print("\n");
				display.print(myRTC.dayofmonth);
				display.print("/");
				display.print(myRTC.month);
				display.setTextSize(1);
				display.print("/");
				display.println(myRTC.year);

				//display.drawRect(0, 0, myRTC.seconds, myRTC.seconds, BLACK);
				//display.print("\nthermistor reading= "); display.print(readThermistor()); display.print("*C");
				display.display();
			}
			break;
		case 2:
			if (millis() - previousMillis1 >= 100) {
				previousMillis1 = millis();

				display.clearDisplay();
				myRTC.updateTime();

				display.setTextWrap(false);

				display.setTextSize(1);
				display.print("H");
				display.setTextSize(2);
				display.println(myRTC.hours, BIN);
				display.setTextSize(1);
				display.print("M");
				display.setTextSize(2);
				display.println(myRTC.minutes, BIN);
				display.setTextSize(1);
				display.print("S");
				display.setTextSize(2);
				display.println(myRTC.seconds, BIN);

				display.setCursor(66, 0);
				display.setTextSize(1);
				display.print("BIN");

				display.setTextWrap(true);

				display.display();
			}
			break;
		case 3:

			if (millis() - previousMillis1 >= 100) {
				previousMillis1 = millis();

				display.clearDisplay();
				myRTC.updateTime();

				display.setTextWrap(false);

				display.setTextSize(1);
				display.print("Hours:");
				display.setTextSize(2);
				display.println(myRTC.hours, HEX);
				display.setTextSize(1);
				display.print("Minutes:");
				display.setTextSize(2);
				display.println(myRTC.minutes, HEX);
				display.setTextSize(1);
				display.print("Seconds:");
				display.setTextSize(2);
				display.println(myRTC.seconds, HEX);

				display.setCursor(66, 0);
				display.setTextSize(1);
				display.print("HEX");

				display.setTextWrap(true);

				display.display();
			}
			break;
		case 4:

			if (millis() - previousMillis1 >= 100) {
				previousMillis1 = millis();

				display.clearDisplay();
				myRTC.updateTime();

				display.setTextWrap(false);

				display.setTextSize(1);
				display.print("Hours:");
				display.setTextSize(2);
				display.println(myRTC.hours, OCT);
				display.setTextSize(1);
				display.print("Minutes:");
				display.setTextSize(2);
				display.println(myRTC.minutes, OCT);
				display.setTextSize(1);
				display.print("Seconds:");
				display.setTextSize(2);
				display.println(myRTC.seconds, OCT);

				display.setCursor(66, 0);
				display.setTextSize(1);
				display.print("OCT");

				display.setTextWrap(true);

				display.display();
			}
			break;
		case 5:

			if (millis() - previousMillis1 >= 100) {
				previousMillis1 = millis();

				display.clearDisplay();
				myRTC.updateTime();

				display.setTextWrap(false);

				//display.setTextSize(1);
				//display.print("H:");
				display.setTextSize(2);
				display.println(DECtoROMAN(myRTC.hours));
				//display.setTextSize(1);
				//display.print("M:");
				display.setTextSize(2);
				display.println(DECtoROMAN(myRTC.minutes));
				display.setTextSize(2);
				display.println(DECtoROMAN(myRTC.seconds));

				display.setCursor(66, 0);
				display.setTextSize(1);
				display.print("ROM");

				display.setTextWrap(true);

				display.display();
			}
			break;
		}
		break;
	case 2:
		display.clearDisplay();
		display.setTextSize(1);
		display.print(F("LEDflashlight:"));
		display.print(F("/hold BTN3/ "));
		display.print(F("\ngl volume:"));
		display.print(globalVolume);
		display.print(F("\nVcc="));
		display.print(vcc.Read_Volts());
		display.print(F("V"));
		//if (cursorState == false)
		//	display.println("       ->");
		//else
		//	display.println("       -->");
		display.display();

		////update cursorState
		//if (millis() - previousMillis1 >= 500){
		//	cursorState = !cursorState;
		//	previousMillis1 = millis();
		//}
		break;


	case 3:
		if (millis() - previousMillis1 >= 100) {
			previousMillis1 = millis();

			display.clearDisplay();
			myRTC.updateTime();

			display.setTextSize(1);

			display.print(" ");
			display.print(myRTC.hours);
			display.print(":");
			display.print(myRTC.minutes);
			display.print(":");
			display.println(myRTC.seconds);
			display.print(myRTC.dayofmonth);
			display.print("/");
			display.print(myRTC.month);
			display.print("/");
			display.print(myRTC.year);


			display.drawCircle(42, 24, 23, BLACK);
			x = 42 + 23 * sin(myRTC.seconds * 360 / 60 * DEG_TO_RAD); y = 24 - 23 * cos(myRTC.seconds * 360 / 60 * DEG_TO_RAD);
			display.drawLine(42, 24, x, y, BLACK);
			x = 42 + 23 * sin(myRTC.minutes * 360 / 60 * DEG_TO_RAD); y = 24 - 23 * cos(myRTC.minutes * 360 / 60 * DEG_TO_RAD);
			display.drawLine(42, 24, x, y, BLACK);
			hours = myRTC.hours;
			if (hours > 12)hours -= 12;
			x = 42 + 18 * sin(hours * 360 / 12 * DEG_TO_RAD); y = 24 - 18 * cos(hours * 360 / 12 * DEG_TO_RAD);
			display.drawLine(42, 24, x, y, BLACK);

			//x=42+23*(sin(heading)* 180/M_PI); y =24-23*(cos(heading)* 180/M_PI);
			display.display();
		}
		break;
	case 4:
		if (millis() - previousMillis1 >= 100) {
			previousMillis1 = millis();
			display.clearDisplay();
			display.setTextSize(1);
			display.println("free RAM:");
			display.print(freeMemory());
			display.println(" bytes");
			display.print("demo-mode=");
			display.println(demoMode);

			myRTC.updateTime();
			display.print(myRTC.hours);
			display.print(":");
			display.print(myRTC.minutes);
			display.print(":");
			display.print(myRTC.seconds);

			temperatureSensors.requestTemperatures();

			display.print("\ntmp:");
			display.print(temperatureSensors.getTempCByIndex(0));
			display.print("*C");
			display.print("\nresolution:");
			display.print(temperatureSensors.getResolution());

			display.display();

		}
		break;
	case 5:
		if (millis() - previousMillis1 >= 100) {
			previousMillis1 = millis();
			display.clearDisplay();
			display.setTextSize(1);
			display.drawBitmap(0, 0, settings_screen, 84, 40, BLACK);
			display.setCursor(0, 41);
			display.print(F("/hold BTN3/"));
			display.display();

		}
		break;
	case 6:
		if (millis() - previousMillis1 >= 100) {
			previousMillis1 = millis();

			display.clearDisplay();
			myRTC.updateTime();

			display.setTextSize(1);

			//display.print(" ");
			//display.print(myRTC.hours);
			//display.print(":");
			//display.print(myRTC.minutes);
			//display.print(":");
			//display.println(myRTC.seconds);
			//display.print(myRTC.dayofmonth);
			//display.print("/");
			//display.print(myRTC.month);
			//display.print("/");
			//display.print(myRTC.year);


			//display.drawCircle(42, 24, 23, BLACK);
			x = 42 + 42 * sin(myRTC.seconds * 360 / 60 * DEG_TO_RAD);
			//if (x > 84)
			//	x = 84;
			//else if (x < 0)
			//	x = 0;
			y = 24 - 42 * cos(myRTC.seconds * 360 / 60 * DEG_TO_RAD);
			//if (y > 48)
			//	y = 48;
			//else if (y < 0)
			//	y = 0;
			display.drawLine(42, 24, x, y, BLACK);
			x = 42 + 42 * sin(myRTC.minutes * 360 / 60 * DEG_TO_RAD); y = 24 - 42 * cos(myRTC.minutes * 360 / 60 * DEG_TO_RAD);
			display.drawLine(42, 24, x, y, BLACK);
			hours = myRTC.hours;
			if (hours > 12)hours -= 12;
			x = 42 + 20 * sin(hours * 360 / 12 * DEG_TO_RAD); y = 24 - 20 * cos(hours * 360 / 12 * DEG_TO_RAD);
			display.drawLine(42, 24, x, y, BLACK);

			//x=42+23*(sin(heading)* 180/M_PI); y =24-23*(cos(heading)* 180/M_PI);
			display.display();
		}
		break;
	case 7:
		display.clearDisplay();
		display.setTextSize(1);
		display.drawBitmap(0, 0, made_by, 84, 48, BLACK);
		display.display();
	}
}

void LEDfadeIN(int numPin, int x){
	for (int i = 0; i <= 255; i++){
		analogWrite(numPin, i);
		delay(x);
	}
	digitalWrite(numPin, HIGH);
}

void LEDfadeOUT(int numPin, int x){
	for (int i = 255; i > 0; i--){
		analogWrite(numPin, i);
		delay(x);
	}
	digitalWrite(numPin, LOW);
}

char* DECtoROMAN(int x){
	static char string[10];
	int cursor;

	for (cursor = 0; x > 0; cursor++){
		if (x / 50 > 0){
			string[cursor] = 'L';
			x -= 50;
		}
		else if (x / 40 > 0){
			string[cursor] = 'X';
			cursor++;
			string[cursor] = 'L';
			x -= 40;
		}
		else if (x / 10 > 0){
			string[cursor] = 'X';
			x -= 10;
		}
		else if (x / 9 > 0){
			string[cursor] = 'I';
			cursor++;
			string[cursor] = 'X';
			x -= 9;
		}
		else if (x / 5 > 0){
			string[cursor] = 'V';
			x -= 5;
		}
		else if (x / 4 > 0){
			string[cursor] = 'I';
			cursor++;
			string[cursor] = 'V';
			x -= 4;
		}
		else if (x > 0){
			string[cursor] = 'I';
			x -= 1;
		}
	}
	string[cursor] = '\0';
	//display.print(string); display.display();
	return string;
}

void sleepNow(void)//fuction for enabling sleep mode
{
	attachInterrupt(0, pinInterrupt, LOW);// Set pin 2 as interrupt and attach handler
	display.clearDisplay();
	display.print(F("sleep mode\nactivated"));
	display.display();
	LEDfadeOUT(BLpin, 1);
	digitalWrite(peripheralsPowerPin, HIGH);//turn peripheral devices off when going to sleep
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);// Choose our preferred sleep mode	
	sleep_enable();// Set sleep enable (SE) bit
	sleep_mode();// Put the device to sleep	

	sleep_disable();//  <--- Upon waking up, sketch continues from this point.

	digitalWrite(peripheralsPowerPin, LOW);//turn peripheral devices on when waking up from sleep mode
	display.clearDisplay();
	display.begin();
	display.setContrast(StartupContrast);
	LEDfadeIN(BLpin, 1);
}
void pinInterrupt(void)//pin interrupt funcion used in attachInterrupt function (when enabling the sleep mode)
{
	detachInterrupt(0);
}


//void shiftLeft1(char *SRbuffer){
//	int nCursor = 0;
//	int j=0;
//	for (nCursor; SRbuffer[nCursor - 1] != ' ' && SRbuffer[nCursor - 1] != ',' && SRbuffer[nCursor - 1] != ';'; nCursor++);
//	for (nCursor; nCursor < strlen(SRbuffer); nCursor++){
//		SRbuffer[j++] = SRbuffer[nCursor];
//	}
//}

//void shiftRight(char *SRbuffer){
//	while (SRbuffer[strlen(SRbuffer) - 1] == ' ')
//		for (int i = strlen(SRbuffer) - 1; i >= 0; i--){
//			SRbuffer[i + 1] = SRbuffer[i];
//			SRbuffer[0] = '0';
//		}
//}
